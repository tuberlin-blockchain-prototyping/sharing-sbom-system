name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  DOCKER_IMAGE: sharing-sbom-system/app

jobs:
  build-and-scan:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./dummyapp
          file: ./dummyapp/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Generate SBOM with Syft
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.DOCKER_IMAGE }}:${{ steps.meta.outputs.tags }}
          format: cyclonedx-json
          output-file: sboms/app.json

      - name: Calculate SBOM hash
        run: |
          sha256sum sboms/app.json | awk '{print $1}' > sboms/app.sha256
          echo "SBOM Hash: $(cat sboms/app.sha256)"

      - name: Upload SBOM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sbom-and-security-reports
          path: |
            sboms/app.json
            sboms/app.sha256
          retention-days: 30

  fetch-cve-banned-list:
    runs-on: ubuntu-latest
    outputs:
      banned_list: ${{ steps.parse.outputs.banned_list }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Fetch CVE data from NVD
        id: fetch_cve
        run: |
          # Fetch recent CVEs (last 30 days)
          # Note: NVD API requires API key for higher rate limits
          # For demo purposes, we'll use a simple approach
          python3 << 'EOF'
          import json
          import urllib.request
          import sys
          
          # Fetch recent CVEs (simplified - in production use NVD API properly)
          # This is a placeholder - you would implement proper CVE fetching
          # For now, we'll use a sample banned list
          banned_list = [
              "log4j-core",
              "log4j-core:2.17.0",
              "pkg:maven/org.apache.logging.log4j/log4j-core@2.17.0"
          ]
          
          # Save to file
          with open('banned_list.txt', 'w') as f:
              for item in banned_list:
                  f.write(item + '\n')
          
          print(f"Created banned list with {len(banned_list)} entries")
          EOF

      - name: Parse CVE data to banned list format
        id: parse
        run: |
          # Convert banned list to JSON array for workflow output
          BANNED_LIST=$(cat banned_list.txt | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "banned_list=$BANNED_LIST" >> $GITHUB_OUTPUT
          echo "Banned list entries:"
          cat banned_list.txt

      - name: Upload banned list
        uses: actions/upload-artifact@v4
        with:
          name: banned-list
          path: banned_list.txt

  generate-proof:
    runs-on: [self-hosted, kind-cluster, blockchain]
    needs: [build-and-scan, fetch-cve-banned-list]
    if: github.event_name == 'push'
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Download SBOM artifacts
        uses: actions/download-artifact@v4
        with:
          name: sbom-and-security-reports
          path: .

      - name: Download banned list
        uses: actions/download-artifact@v4
        with:
          name: banned-list
          path: .

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Wait for proving-service to be ready
        run: |
          kubectl wait --for=condition=available --timeout=300s deployment/proving-service -n sharing-sbom-system || true

      - name: Call proving-service to generate proof
        id: prove
        run: |
          PROVING_SERVICE_URL="http://proving-service.sharing-sbom-system.svc.cluster.local"
          
          # Read SBOM and banned list
          SBOM_JSON=$(cat sboms/app.json)
          BANNED_LIST=$(cat banned_list.txt | jq -R -s -c 'split("\n") | map(select(length > 0))')
          
          # Create request payload with SBOM and banned list
          REQUEST_PAYLOAD=$(jq -n \
            --argjson sbom "$SBOM_JSON" \
            --argjson banned_list "$BANNED_LIST" \
            '{sbom: $sbom, banned_list: $banned_list}')
          
          echo "Calling proving-service with SBOM and banned list..."
          RESPONSE=$(curl -s -X POST "$PROVING_SERVICE_URL/prove" \
            -H "Content-Type: application/json" \
            -d "$REQUEST_PAYLOAD")
          
          echo "$RESPONSE" | jq .
          
          # Extract values
          PROOF=$(echo "$RESPONSE" | jq -r '.proof')
          SBOM_HASH=$(echo "$RESPONSE" | jq -r '.sbom_hash')
          IMAGE_ID=$(echo "$RESPONSE" | jq -r '.image_id | join(",")')
          IS_VALID=$(echo "$RESPONSE" | jq -r '.proof_info.is_valid')
          BANNED_LIST_HASH=$(echo "$RESPONSE" | jq -r '.proof_info.banned_list_info.hash')
          
          echo "proof=$PROOF" >> $GITHUB_OUTPUT
          echo "sbom_hash=$SBOM_HASH" >> $GITHUB_OUTPUT
          echo "image_id=$IMAGE_ID" >> $GITHUB_OUTPUT
          echo "is_valid=$IS_VALID" >> $GITHUB_OUTPUT
          echo "banned_list_hash=$BANNED_LIST_HASH" >> $GITHUB_OUTPUT
          
          # Save proof info
          echo "$RESPONSE" | jq . > proof_info.json

      - name: Store proof on IPFS
        id: ipfs
        run: |
          IPFS_SERVICE_URL="http://ipfs-service.sharing-sbom-system.svc.cluster.local"
          
          STORE_PAYLOAD=$(jq -n \
            --arg proof "${{ steps.prove.outputs.proof }}" \
            --arg sbom_hash "${{ steps.prove.outputs.sbom_hash }}" \
            '{proof: $proof, sbom_hash: $sbom_hash}')
          
          echo "Storing proof on IPFS..."
          IPFS_RESPONSE=$(curl -s -X POST "$IPFS_SERVICE_URL/store" \
            -H "Content-Type: application/json" \
            -d "$STORE_PAYLOAD")
          
          echo "$IPFS_RESPONSE" | jq .
          
          IPFS_CID=$(echo "$IPFS_RESPONSE" | jq -r '.ipfs_cid')
          echo "ipfs_cid=$IPFS_CID" >> $GITHUB_OUTPUT

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          npm install ethers@^6.0.0

      - name: Write to blockchain
        run: |
          RPC_URL="http://hardhat-node.blockchain.svc.cluster.local:8545"
          CONTRACT_ADDR="0x5FbDB2315678afecb367f032d93F642f64180aa3"
          SBOM_HASH="${{ steps.prove.outputs.sbom_hash }}"
          IMAGE_NAME="${{ env.DOCKER_IMAGE }}:${{ needs.build-and-scan.outputs.image_tag }}"
          IDENTIFIER="github-ci-${{ github.run_id }}"
          IMAGE_ID="${{ steps.prove.outputs.image_id }}"
          IPFS_CID="${{ steps.ipfs.outputs.ipfs_cid }}"
          IS_VALID="${{ steps.prove.outputs.is_valid }}"
          BANNED_LIST_HASH="${{ steps.prove.outputs.banned_list_hash }}"
          PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"
          
          echo "Writing to blockchain..."
          echo "  Contract: $CONTRACT_ADDR"
          echo "  SBOM Hash: $SBOM_HASH"
          echo "  Image: $IMAGE_NAME"
          echo "  Identifier: $IDENTIFIER"
          echo "  Image ID: $IMAGE_ID"
          echo "  IPFS CID: $IPFS_CID"
          echo "  Is Valid: $IS_VALID"
          echo "  Banned List Hash: $BANNED_LIST_HASH"
          
          export RPC_URL CONTRACT_ADDR SBOM_HASH IMAGE_NAME IDENTIFIER IMAGE_ID IPFS_CID IS_VALID BANNED_LIST_HASH PRIVATE_KEY
          TX_HASH=$(node << 'EOF'
          const { ethers } = require("ethers");
          
          const RPC_URL = process.env.RPC_URL;
          const CONTRACT_ADDR = process.env.CONTRACT_ADDR;
          const SBOM_HASH = process.env.SBOM_HASH;
          const IMAGE_NAME = process.env.IMAGE_NAME;
          const IDENTIFIER = process.env.IDENTIFIER;
          const IMAGE_ID_STR = process.env.IMAGE_ID;
          const IPFS_CID = process.env.IPFS_CID;
          const IS_VALID = process.env.IS_VALID === "true";
          const BANNED_LIST_HASH = process.env.BANNED_LIST_HASH;
          const PRIVATE_KEY = process.env.PRIVATE_KEY;
          
          (async () => {
            try {
              const provider = new ethers.JsonRpcProvider(RPC_URL);
              const wallet = new ethers.Wallet(PRIVATE_KEY, provider);
            
              const abi = [
                "function storeSBOM(bytes32 hash, string image, string identifier, bytes32 imageId, string ipfsCid, bool isValid, bytes32 bannedListHash) external",
              ];
            
              const contract = new ethers.Contract(CONTRACT_ADDR, abi, wallet);
            
              const hashBytes32 = "0x" + SBOM_HASH;
              
              const u32s = IMAGE_ID_STR.split(",").map(s => parseInt(s.trim(), 10));
              if (u32s.length !== 8) {
                throw new Error(`Expected 8 u32 values, got ${u32s.length}`);
              }
              
              const buffer = new ArrayBuffer(32);
              const view = new DataView(buffer);
              for (let i = 0; i < 8; i++) {
                view.setUint32(i * 4, u32s[i], true);
              }
              
              const imageIdBytes32 = ethers.hexlify(new Uint8Array(buffer));
              
              const bannedListHashBytes32 = BANNED_LIST_HASH.startsWith("0x") 
                ? BANNED_LIST_HASH 
                : "0x" + BANNED_LIST_HASH;
              
              console.log("Sending transaction...");
              const tx = await contract.storeSBOM(
                hashBytes32, 
                IMAGE_NAME, 
                IDENTIFIER, 
                imageIdBytes32,
                IPFS_CID,
                IS_VALID,
                bannedListHashBytes32
              );
              console.log("Transaction sent:", tx.hash);
            
              console.log("Waiting for confirmation...");
              const receipt = await tx.wait();
              console.log("Transaction confirmed:", receipt.hash);
              console.log(receipt.hash);
            } catch (error) {
              console.error("Error:", error);
              process.exit(1);
            }
          })();
          EOF
          )
          
          echo "Transaction Hash: $TX_HASH"
          echo "$TX_HASH" > tx_hash.txt

      - name: Upload proof artifacts
        uses: actions/upload-artifact@v4
        with:
          name: proof-artifacts
          path: |
            proof_info.json
            tx_hash.txt
          retention-days: 30

