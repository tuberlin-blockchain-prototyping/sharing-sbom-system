name: CI/CD Dummyapp

# Builds a dummy application, generates SBOM, and creates ZKP proof
# Uses the deployed microservices to validate and store the proof
# Note: dummyapp2 has minimal dependencies for faster proof generation

on:
  push:
    branches: [main]
    paths-ignore:
      - 'k8s/**'

jobs:
  build-and-scan:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/sharing-sbom-system-app
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./dummyapp2
          file: ./dummyapp2/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Create sboms directory
        run: mkdir -p sboms

      - name: Generate SBOM with Syft
        uses: anchore/sbom-action@v0
        with:
          image: ${{ secrets.DOCKER_USERNAME }}/sharing-sbom-system-app:latest
          format: cyclonedx-json
          output-file: sboms/app.json

      - name: Calculate SBOM hash
        run: |
          sha256sum sboms/app.json | awk '{print $1}' > sboms/app.sha256
          echo "SBOM Hash: $(cat sboms/app.sha256)"

      - name: Upload SBOM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sbom-and-security-reports
          path: |
            sboms/app.json
            sboms/app.sha256
          retention-days: 30

  fetch-cve-banned-list:
    runs-on: ubuntu-latest
    outputs:
      banned_list: ${{ steps.parse.outputs.banned_list }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Fetch CVE data from NVD
        id: fetch_cve
        run: |
          python3 << 'EOF'
          import json
          import urllib.request
          import sys
          
          banned_list = [
              "log4j-core",
              "log4j-core:2.17.0",
              "pkg:maven/org.apache.logging.log4j/log4j-core@2.17.0"
          ]
          
          with open('banned_list.txt', 'w') as f:
              for item in banned_list:
                  f.write(item + '\n')
          
          print(f"Created banned list with {len(banned_list)} entries")
          EOF

      - name: Parse CVE data to banned list format
        id: parse
        run: |
          BANNED_LIST=$(cat banned_list.txt | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "banned_list=$BANNED_LIST" >> $GITHUB_OUTPUT
          echo "Banned list entries:"
          cat banned_list.txt

      - name: Upload banned list
        uses: actions/upload-artifact@v4
        with:
          name: banned-list
          path: banned_list.txt

  generate-proof:
    runs-on: [self-hosted, kind-cluster, blockchain]
    needs: [build-and-scan, fetch-cve-banned-list]
    timeout-minutes: 60
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Download SBOM artifacts
        uses: actions/download-artifact@v4
        with:
          name: sbom-and-security-reports
          path: .
          if-no-files-found: error

      - name: Download banned list
        uses: actions/download-artifact@v4
        with:
          name: banned-list
          path: .
          if-no-files-found: error

      - name: Verify and locate artifacts
        id: locate
        run: |
          echo "Current directory: $(pwd)"
          echo "Files in current directory:"
          ls -la
          echo ""
          echo "Creating hardcoded SBOM for proving service (with unique run ID)..."
          RUN_ID="${{ github.run_id }}"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          cat > sbom.json << EOF
          {
            "bomFormat": "CycloneDX",
            "specVersion": "1.4",
            "version": 1,
            "metadata": {
              "timestamp": "${TIMESTAMP}",
              "ciRunId": "${RUN_ID}"
            },
            "components": [
              {
                "type": "library",
                "name": "express",
                "version": "4.18.2",
                "purl": "pkg:npm/express@4.18.2"
              },
              {
                "type": "library",
                "name": "lodash",
                "version": "4.17.21",
                "purl": "pkg:npm/lodash@4.17.21"
              },
              {
                "type": "library",
                "name": "axios",
                "version": "1.0.0",
                "purl": "pkg:npm/axios@1.0.0"
              }
            ]
          }
          EOF
          echo "Run ID: ${RUN_ID}, Timestamp: ${TIMESTAMP}"
          echo "sbom_file=sbom.json" >> $GITHUB_OUTPUT
          echo "Hardcoded SBOM file created: sbom.json"
          echo "SBOM file size: $(wc -c < sbom.json) bytes"
          
          # Verify generated SBOM exists
          if [ -f "sboms/app.json" ]; then
            echo "Generated SBOM found at sboms/app.json (kept for reference, not used for proving)"
          fi
          
          if [ ! -f "banned_list.txt" ]; then
            echo "ERROR: banned_list.txt not found!"
            ls -la
            exit 1
          fi

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Wait for proving-service to be ready
        run: |
          echo "Checking if proving-service deployment exists..."
          kubectl get deployment proving-service -n sharing-sbom-system || echo "Deployment not found, continuing..."
          echo "Waiting for proving-service to be available..."
          kubectl wait --for=condition=available --timeout=300s deployment/proving-service -n sharing-sbom-system || echo "Wait timeout, checking service status..."
          kubectl get pods -n sharing-sbom-system -l app=proving-service || true
          echo "Checking service endpoint..."
          kubectl get svc proving-service -n sharing-sbom-system || true
          
          echo "Waiting for service to be fully ready and DNS to resolve..."
          PROVING_SERVICE_URL="http://proving-service.sharing-sbom-system.svc.cluster.local"
          MAX_RETRIES=30
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -s --max-time 5 "$PROVING_SERVICE_URL/health" > /dev/null 2>&1; then
              echo "✓ Service is reachable after $RETRY_COUNT retries"
              break
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Waiting for service... (attempt $RETRY_COUNT/$MAX_RETRIES)"
            sleep 2
          done
          
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "WARNING: Service health check failed after $MAX_RETRIES attempts"
            echo "Checking pod status..."
            kubectl get pods -n sharing-sbom-system -l app=proving-service || true
            kubectl logs -n sharing-sbom-system -l app=proving-service --tail=20 || true
          fi

      - name: Call proving-service to generate proof
        id: prove
        timeout-minutes: 45
        run: |
          PROVING_SERVICE_URL="http://proving-service.sharing-sbom-system.svc.cluster.local"
          SBOM_FILE="${{ steps.locate.outputs.sbom_file }}"
          
          if [ ! -f "$SBOM_FILE" ]; then
            echo "ERROR: SBOM file not found at $SBOM_FILE"
            exit 1
          fi
          
          echo "SBOM file size: $(wc -c < "$SBOM_FILE") bytes"
          echo "Preparing request payload..."
          
          BANNED_LIST=$(cat banned_list.txt | jq -R -s -c 'split("\n") | map(select(length > 0))')
          
          jq -n \
            --slurpfile sbom "$SBOM_FILE" \
            --argjson banned_list "$BANNED_LIST" \
            '{sbom: $sbom[0], banned_list: $banned_list}' > request_payload.json
          
          echo "Request payload size: $(wc -c < request_payload.json) bytes"
          echo "Calling proving-service at $PROVING_SERVICE_URL/prove..."
          
          # Service should already be ready from previous step, but verify once more
          echo "Verifying service connectivity..."
          if ! curl -s --max-time 10 "$PROVING_SERVICE_URL/health" > /dev/null 2>&1; then
            echo "WARNING: Health check failed, but proceeding with proof generation..."
            echo "Service might be slow to respond, but should handle the request"
          else
            echo "✓ Service connectivity confirmed"
          fi
          
          echo "Sending proof generation request (this may take 10-30 minutes for large SBOMs)..."
          
          RESPONSE_FILE=$(mktemp)
          HTTP_CODE_FILE=$(mktemp)
          
          curl -X POST "$PROVING_SERVICE_URL/prove" \
            -H "Content-Type: application/json" \
            --data-binary @request_payload.json \
            --max-time 1800 \
            --connect-timeout 30 \
            --write-out "%{http_code}" \
            --output "$RESPONSE_FILE" \
            --silent \
            --show-error > "$HTTP_CODE_FILE" 2>&1
          
          HTTP_CODE=$(cat "$HTTP_CODE_FILE")
          echo "HTTP Status Code: $HTTP_CODE"
          
          if [ -z "$HTTP_CODE" ] || [ "$HTTP_CODE" != "200" ]; then
            echo "ERROR: Proving service returned non-200 status code or connection failed"
            echo "Response preview (first 500 chars):"
            head -c 500 "$RESPONSE_FILE" || true
            echo ""
            echo "Checking service logs..."
            kubectl logs -n sharing-sbom-system -l app=proving-service --tail=50 || true
            echo "Checking if proof generation is still in progress..."
            kubectl get pods -n sharing-sbom-system -l app=proving-service || true
            rm -f "$RESPONSE_FILE" "$HTTP_CODE_FILE"
            exit 1
          fi
          
          RESPONSE_BODY=$(cat "$RESPONSE_FILE")
          echo "$RESPONSE_BODY" | jq .
          
          PROOF=$(echo "$RESPONSE_BODY" | jq -r '.proof')
          SBOM_HASH=$(echo "$RESPONSE_BODY" | jq -r '.sbom_hash')
          IMAGE_ID=$(echo "$RESPONSE_BODY" | jq -r '.image_id | join(",")')
          IS_VALID=$(echo "$RESPONSE_BODY" | jq -r '.proof_info.is_valid')
          BANNED_LIST_HASH=$(echo "$RESPONSE_BODY" | jq -r '.proof_info.banned_list_info.hash')
          
          echo "proof=$PROOF" >> $GITHUB_OUTPUT
          echo "sbom_hash=$SBOM_HASH" >> $GITHUB_OUTPUT
          echo "image_id=$IMAGE_ID" >> $GITHUB_OUTPUT
          echo "is_valid=$IS_VALID" >> $GITHUB_OUTPUT
          echo "banned_list_hash=$BANNED_LIST_HASH" >> $GITHUB_OUTPUT
          
          echo "$RESPONSE_BODY" | jq . > proof_info.json
          rm -f "$RESPONSE_FILE" "$HTTP_CODE_FILE"

      - name: Store proof on IPFS
        id: ipfs
        run: |
          IPFS_SERVICE_URL="http://ipfs-service.sharing-sbom-system.svc.cluster.local"
          
          PROOF_FILE=$(mktemp)
          echo "${{ steps.prove.outputs.proof }}" > "$PROOF_FILE"
          
          STORE_PAYLOAD_FILE=$(mktemp)
          jq -n \
            --rawfile proof "$PROOF_FILE" \
            --arg sbom_hash "${{ steps.prove.outputs.sbom_hash }}" \
            '{proof: $proof, sbom_hash: $sbom_hash}' > "$STORE_PAYLOAD_FILE"
          
          echo "Storing proof on IPFS..."
          IPFS_RESPONSE=$(curl -s -X POST "$IPFS_SERVICE_URL/store" \
            -H "Content-Type: application/json" \
            -d @"$STORE_PAYLOAD_FILE")
          
          echo "$IPFS_RESPONSE" | jq .
          
          IPFS_CID=$(echo "$IPFS_RESPONSE" | jq -r '.ipfs_cid')
          echo "ipfs_cid=$IPFS_CID" >> $GITHUB_OUTPUT
          
          rm -f "$PROOF_FILE" "$STORE_PAYLOAD_FILE"

      - name: Write to blockchain
        run: |
          CONTRACT_ADDR="0x5FbDB2315678afecb367f032d93F642f64180aa3"
          SBOM_HASH="${{ steps.prove.outputs.sbom_hash }}"
          
          # Extract Docker image digest (format: sha256:abc123...)
          IMAGE_DIGEST="${{ needs.build-and-scan.outputs.image_digest }}"
          
          # Remove "sha256:" prefix if present, keep only the hash
          if [[ "$IMAGE_DIGEST" == sha256:* ]]; then
            SOFTWARE_DIGEST="${IMAGE_DIGEST#sha256:}"
          else
            SOFTWARE_DIGEST="$IMAGE_DIGEST"
          fi
          
          # Verify digest format (64 hex chars)
          if [[ ! "$SOFTWARE_DIGEST" =~ ^[0-9a-fA-F]{64}$ ]]; then
            echo "ERROR: Invalid software digest format: $SOFTWARE_DIGEST"
            echo "Expected 64 hex characters (with or without sha256: prefix)"
            exit 1
          fi
          
          IDENTIFIER="github-ci-${{ github.run_id }}"
          IMAGE_ID="${{ steps.prove.outputs.image_id }}"
          IPFS_CID="${{ steps.ipfs.outputs.ipfs_cid }}"
          IS_VALID="${{ steps.prove.outputs.is_valid }}"
          BANNED_LIST_HASH="${{ steps.prove.outputs.banned_list_hash }}"
          
          echo "Writing to blockchain..."
          echo "  Contract: $CONTRACT_ADDR"
          echo "  SBOM Hash: $SBOM_HASH"
          echo "  Software Digest: sha256:$SOFTWARE_DIGEST"
          echo "  Identifier: $IDENTIFIER"
          echo "  Image ID: $IMAGE_ID"
          echo "  IPFS CID: $IPFS_CID"
          echo "  Is Valid: $IS_VALID"
          echo "  Banned List Hash: $BANNED_LIST_HASH"
          
          # Get Hardhat pod name
          HARDHAT_POD=$(kubectl get pods -n blockchain -l app=hardhat-node -o jsonpath='{.items[0].metadata.name}')
          
          if [ -z "$HARDHAT_POD" ]; then
            echo "ERROR: Hardhat node not found"
            exit 1
          fi
          
          echo "Found Hardhat pod: $HARDHAT_POD"
          
          kubectl cp scripts/blockchain/store_sbom.js "blockchain/$HARDHAT_POD:/workspace/store_sbom.js"
          
          # Run store_sbom.js in Hardhat pod using Hardhat runtime environment
          echo "Executing store_sbom.js in Hardhat pod..."
          TX_OUTPUT=$(kubectl exec -n blockchain "$HARDHAT_POD" -- sh -c "cd /workspace && ADDR='$CONTRACT_ADDR' HASH='$SBOM_HASH' SOFTWARE_DIGEST='$SOFTWARE_DIGEST' IDENT='$IDENTIFIER' IMAGE_ID='$IMAGE_ID' IPFS_CID='$IPFS_CID' IS_VALID='$IS_VALID' BANNED_LIST_HASH='$BANNED_LIST_HASH' npx hardhat run store_sbom.js --network localhost 2>&1")
          
          echo "$TX_OUTPUT"
          
          # Extract transaction hash (last line)
          TX_HASH=$(echo "$TX_OUTPUT" | tail -n1)
          
          # Verify it's a valid transaction hash
          if [[ ! "$TX_HASH" =~ ^0x[0-9a-fA-F]{64}$ ]]; then
            echo "ERROR: Invalid transaction hash: $TX_HASH"
            exit 1
          fi
          
          echo "Transaction Hash: $TX_HASH"
          echo "$TX_HASH" > tx_hash.txt

      - name: Upload proof artifacts
        uses: actions/upload-artifact@v4
        with:
          name: proof-artifacts
          path: |
            proof_info.json
            tx_hash.txt
          retention-days: 30

